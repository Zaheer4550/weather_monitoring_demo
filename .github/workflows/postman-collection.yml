name: Automated API tests using Postman CLI

on: push

jobs:
  automated-api-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install dependencies (Postman CLI + jq)
        run: |
          curl -o- "https://dl-cli.pstmn.io/install/linux64.sh" | sh
          sudo apt-get update && sudo apt-get install -y jq

      - name: Login to Postman CLI
        run: postman login --with-api-key ${{ secrets.POSTMAN_API_KEY }}

      # --- Update collection in Postman by UID (requires wrapper) ---
      - name: Sync Collection to Postman (wrapped payload)
        env:
          POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
          POSTMAN_COLLECTION_UID: ${{ secrets.POSTMAN_COLLECTION_UID }}
          POSTMAN_API_BASE: ${{ secrets.POSTMAN_API_BASE }}
        run: |
          API_BASE="${POSTMAN_API_BASE:-https://api.getpostman.com}"

          FILE="Weather_Monitoring_Demo.postman_collection.json"
          test -f "$FILE" || { echo "Collection file not found: $FILE"; exit 1; }

          # Wrap as { "collection": <file JSON> }
          jq -n --slurpfile c "$FILE" '{collection: $c[0]}' > wrapped_collection.json

          echo "Updating collection ${POSTMAN_COLLECTION_UID}..."
          curl -sS -X PUT "${API_BASE}/collections/${POSTMAN_COLLECTION_UID}" \
            -H "X-Api-Key: ${POSTMAN_API_KEY}" \
            -H "Content-Type: application/json" \
            --data-binary @wrapped_collection.json \
            -o update_collection_response.json

          echo "Update response:" && cat update_collection_response.json
          jq -e 'if has("error") then halt_error(1) else . end' update_collection_response.json >/dev/null

     # --- Detect API base (US/EU) and verify auth ---
- name: Detect Postman API base (US/EU)
  id: api_base
  env:
    POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
    # if you already know you're EU, you can set POSTMAN_API_BASE secret and skip detection
  run: |
    set -e
    for BASE in "https://api.getpostman.com" "https://api.eu.postman.com"; do
      CODE=$(curl -s -o /dev/null -w "%{http_code}" \
        -H "X-Api-Key: ${POSTMAN_API_KEY}" "${BASE}/me")
      if [ "$CODE" = "200" ]; then
        echo "API_BASE=$BASE" >> $GITHUB_ENV
        echo "Using $BASE"
        exit 0
      fi
    done
    echo "Could not reach Postman API in US or EU with given API key." >&2
    exit 1

# --- Verify monitor UID, and read its collectionUid (source of truth) ---
- name: Verify monitor UID and resolve collection UID
  id: resolve_ids
  env:
    POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
    POSTMAN_MONITOR_UID: ${{ secrets.POSTMAN_MONITOR_UID }}
  run: |
    set -e
    test -n "$POSTMAN_MONITOR_UID" || { echo "POSTMAN_MONITOR_UID not set"; exit 1; }

    RESP=$(curl -s -H "X-Api-Key: ${POSTMAN_API_KEY}" \
      "${API_BASE}/monitors/${POSTMAN_MONITOR_UID}")

    # If 404, show monitors to help diagnose and fail early
    if echo "$RESP" | jq -e '.monitor' >/dev/null 2>&1; then
      :
    else
      echo "Monitor not found by UID: $POSTMAN_MONITOR_UID"
      echo "API response:"; echo "$RESP"
      echo "Listing available monitors to help you pick the correct UID:"
      curl -s -H "X-Api-Key: ${POSTMAN_API_KEY}" "${API_BASE}/monitors" | jq '.monitors[] | {name, uid}'
      exit 1
    fi

    COLLECTION_UID=$(echo "$RESP" | jq -r '.monitor.collectionUid')
    MONITOR_NAME=$(echo "$RESP" | jq -r '.monitor.name')
    echo "Resolved monitor: $MONITOR_NAME"
    echo "Resolved collection UID: $COLLECTION_UID"

    echo "COLLECTION_UID=$COLLECTION_UID" >> $GITHUB_ENV

# --- Update the collection by the exact UID the monitor uses (proper wrapper) ---
- name: Sync collection (PUT /collections/{uid})
  env:
    POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
  run: |
    set -e
    FILE="Weather_Monitoring_Demo.postman_collection.json"
    test -f "$FILE" || { echo "Collection file not found: $FILE"; exit 1; }

    jq -n --slurpfile c "$FILE" '{collection: $c[0]}' > wrapped_collection.json

    UPDATE=$(curl -sS -X PUT "${API_BASE}/collections/${COLLECTION_UID}" \
      -H "X-Api-Key: ${POSTMAN_API_KEY}" \
      -H "Content-Type: application/json" \
      --data-binary @wrapped_collection.json)

    echo "Update response:"; echo "$UPDATE"
    echo "$UPDATE" | jq -e 'if has("error") then halt_error(1) else . end' >/dev/null

# --- Trigger, then poll results/latest (aligned to this run) ---
- name: Trigger monitor run
  id: trigger
  env:
    POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
    POSTMAN_MONITOR_UID: ${{ secrets.POSTMAN_MONITOR_UID }}
  run: |
    set -e
    curl -s -X POST "${API_BASE}/monitors/${POSTMAN_MONITOR_UID}/run" \
      -H "X-Api-Key: ${POSTMAN_API_KEY}" \
      -H "Content-Type: application/json" \
      -o trigger_response.json
    echo "Trigger response:"; cat trigger_response.json || true
    TRIGGER_STARTED_AT=$(jq -r '.run.info.startedAt // .run.info.startTime // empty' trigger_response.json)
    echo "TRIGGER_STARTED_AT=${TRIGGER_STARTED_AT:-}" >> $GITHUB_ENV

- name: Wait for monitor run and fetch results
  env:
    POSTMAN_API_KEY: ${{ secrets.POSTMAN_API_KEY }}
    POSTMAN_MONITOR_UID: ${{ secrets.POSTMAN_MONITOR_UID }}
  run: |
    set -e
    TARGET_START="${TRIGGER_STARTED_AT:-}"
    echo "Waiting for monitor run to finish..."
    ATTEMPTS=0; MAX_ATTEMPTS=60
    while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
      sleep 10
      RESP=$(curl -s -H "X-Api-Key: ${POSTMAN_API_KEY}" \
        "${API_BASE}/monitors/${POSTMAN_MONITOR_UID}/results/latest")

      # 404? Surface it immediately (most common cause: wrong UID/region)
      if echo "$RESP" | jq -e '.status? // empty' >/dev/null 2>&1; then
        # problem+json
        echo "API problem response:"; echo "$RESP"
        exit 1
      fi

      STATUS=$(echo "$RESP" | jq -r '.run.status // empty')
      RUN_START=$(echo "$RESP" | jq -r '.run.info.startTime // empty')

      if [ -z "$STATUS" ] || [ -z "$RUN_START" ]; then
        echo "No run yet; body:"; echo "$RESP"
        ATTEMPTS=$((ATTEMPTS+1)); continue
      fi

      if [ -n "$TARGET_START" ] && [ "$RUN_START" \< "$TARGET_START" ]; then
        echo "Seen older run ($RUN_START); waiting for the triggered one ($TARGET_START)..."
        ATTEMPTS=$((ATTEMPTS+1)); continue
      fi

      echo "Current status: $STATUS (started: $RUN_START)"
      if [ "$STATUS" = "finished" ] || [ "$STATUS" = "error" ]; then
        echo "$RESP" > monitor_results.json
        break
      fi
      ATTEMPTS=$((ATTEMPTS+1))
    done

    test -f monitor_results.json || { echo "Timed out waiting for run results."; echo "$RESP" > monitor_results.json; }

# --- Export CSV (adds region + start time) ---
- name: Convert monitor results to CSV (with region)
  run: |
    jq -r '
      . as $root
      | ($root.run.executions // [])[]
      | [
          .item.name,
          (.response.code // "NA"),
          (.response.status // "NA"),
          (.response.responseTime // "NA"),
          ($root.run.info.region // "unknown"),
          ($root.run.info.startTime // "unknown")
        ] | @csv
    ' monitor_results.json > monitor_results.csv
